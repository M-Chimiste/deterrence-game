//! Track lifecycle management.
//!
//! Promotes DetectionCounter entities to full TrackInfo when hits threshold is reached.
//! Drops tracks when quality reaches 0 or misses exceed threshold.

use hecs::World;

use deterrence_core::components::{DetectionCounter, TrackInfo};
use deterrence_core::constants::*;
use deterrence_core::enums::*;
use deterrence_core::events::AudioEvent;
use deterrence_core::types::Position;

/// Promote entities from pre-track (DetectionCounter) to full track (TrackInfo).
/// Drop tracks that have degraded below threshold.
/// Returns audio events generated by promotions and drops.
pub fn run(
    world: &mut World,
    next_track_number: &mut u32,
    despawn_buffer: &mut Vec<hecs::Entity>,
) -> Vec<AudioEvent> {
    let mut events = Vec::new();

    // Phase 1: Collect entities ready for promotion
    let mut promote: Vec<(hecs::Entity, f64)> = Vec::new();

    {
        let mut query = world.query::<(&DetectionCounter, &Position)>();
        for (entity, (counter, pos)) in query.iter() {
            if counter.hits >= TRACK_INITIATE_HITS {
                promote.push((entity, pos.bearing_to(&Position::default())));
            }
        }
    }

    // Phase 2: Promote — remove DetectionCounter, add TrackInfo
    for (entity, bearing) in promote {
        let _ = world.remove_one::<DetectionCounter>(entity);

        let track_number = *next_track_number;
        *next_track_number += 1;

        let _ = world.insert_one(
            entity,
            TrackInfo {
                track_number,
                quality: TRACK_INITIAL_QUALITY,
                classification: Classification::Unknown,
                iff_status: IffStatus::NoResponse,
                hooked: false,
                hits: TRACK_INITIATE_HITS,
                misses: 0,
            },
        );

        events.push(AudioEvent::NewContact {
            bearing,
            track_number,
        });
    }

    // Phase 3: Collect tracks to drop (quality <= 0 or too many misses)
    despawn_buffer.clear();
    {
        let mut query = world.query::<&TrackInfo>();
        for (entity, track) in query.iter() {
            if track.misses >= TRACK_DROP_MISSES || track.quality <= 0.0 {
                despawn_buffer.push(entity);
            }
        }
    }

    // Phase 4: Drop tracks — remove TrackInfo, re-add DetectionCounter for re-detection
    for &entity in despawn_buffer.iter() {
        // Grab track number before removing for event
        let track_number = world.get::<&TrackInfo>(entity).map(|t| t.track_number).ok();

        let _ = world.remove_one::<TrackInfo>(entity);
        let _ = world.insert_one(entity, DetectionCounter::default());

        if let Some(tn) = track_number {
            events.push(AudioEvent::ContactLost { track_number: tn });
        }
    }
    despawn_buffer.clear();

    events
}
